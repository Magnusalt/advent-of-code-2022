#!meta

{"kernelInfo":{"defaultKernelName":null,"items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"html","languageName":"HTML"},{"name":"sql","languageName":"SQL"},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"httpRequest","languageName":"http"},{"name":"value"}]}}

#!markdown

Read input from files

#!csharp

#!value --from-file input1.txt --name input1
#!value --from-file input2.txt --name input2
#!value --from-file input3.txt --name input3
#!value --from-file input4.txt --name input4
#!value --from-file input5.txt --name input5
#!value --from-file input6.txt --name input6
#!value --from-file input7.txt --name input7
#!value --from-file input8.txt --name input8
#!value --from-file input9.txt --name input9

#!markdown

Helpers

#!csharp

using System.Linq;

int[] ParseInput(string[] raw){
    return raw.Select(v=> int.Parse(v)).ToArray();
}

int[] ParseInput(string raw){
    return ParseInput(raw.Split('\n')).ToArray();
}

string[] GetLines(string input){
  return input.Split("\r\n");  
}

#!markdown

Day 1 part 1

#!csharp

#!share input1 --from value

var day1 = input1.Split("\r\n");
var most = 0;
var current = 0;
foreach(var cal in day1)
{
    if(string.IsNullOrEmpty(cal))
    {
        most = current > most ? current : most;
        current = 0;
    }
    else
    {
        current += int.Parse(cal);
    }
}
most

#!markdown

Day 1 part 2

#!csharp

#!share input1 --from value

var day1 = input1.Split("\r\n");
var most = new int[]{0,0,0};
var current = 0;
foreach(var cal in day1)
{
    if(string.IsNullOrEmpty(cal))
    {
        for(var i = 0; i < 3; i++)
        {
            if(current > most[i])
            {
                most[i] = current;
                break;
            }
        }
        current = 0;
    }
    else
    {
        current += int.Parse(cal);
    }
}
most.Sum()

#!markdown

Day 2 part 1

#!csharp

#!share input2 --from value

var input = GetLines(input2);

var res = input.Aggregate(0, (sum, next) =>{
    return sum + next switch {
        "A X" => 1+3,
        "A Y" => 2+6,
        "A Z" => 3+0,
        "B X" => 1+0,
        "B Y" => 2+3,
        "B Z" => 3+6,
        "C X" => 1+6,
        "C Y" => 2+0,
        "C Z" => 3+3,
        _ => throw new ArgumentOutOfRangeException($"{next} is invalid")
    };
});

res

#!markdown

Day 2 part 2

#!csharp

#!share input2 --from value

var input = GetLines(input2);

var res = input.Aggregate(0, (sum, next) =>{
    return sum + next switch {
        "A X" => 3+0,
        "A Y" => 1+3,
        "A Z" => 2+6,
        "B X" => 1+0,
        "B Y" => 2+3,
        "B Z" => 3+6,
        "C X" => 2+0,
        "C Y" => 3+3,
        "C Z" => 1+6,
    };
});

res

#!javascript

#!share input2 --from value

var input = input2.split("\r\n");
var rules = {        
    "A X" : 3+0,
    "A Y" : 1+3,
    "A Z" : 2+6,
    "B X" : 1+0,
    "B Y" : 2+3,
    "B Z" : 3+6,
    "C X" : 2+0,
    "C Y" : 3+3,
    "C Z" : 1+6,
};
var result = input.reduce((sum, next) =>sum + rules[next], 0);
console.log(result)

#!markdown

Day 3 part1

#!csharp

#!share input3 --from value

var input = GetLines(input3);
var prioSum = 0;
foreach(var rucksack in input)
{
    var size = rucksack.Length;
    var compartment1 = rucksack.Substring(0, size/2);
    var compartment2 = rucksack.Substring(size/2);

    foreach(var item in compartment2)
    {
        if(compartment1.Contains(item))
        {
            if(item < 91)
            {
                var prio = item - 65 + 27;
                prioSum += prio;
                break;
            }
            if(item > 96)
            {
                var prio = item - 96;
                prioSum += prio;
                break;
            }
        }
    }
}

prioSum

#!markdown

Day 3 Part 2

#!csharp

#!share input3 --from value

var input = GetLines(input3);
var prioSum = 0;
foreach(var group in input.Chunk(3))
{
    var intersection = group.First().ToList();
    foreach(var rucksack in group.Skip(1))
    {
        intersection = intersection.Intersect(rucksack).ToList();
    }
    var item = intersection.Single();
    if(item < 91)
    {
        var prio = item - 65 + 27;
        prioSum += prio;
    }
    if(item > 96)
    {
        var prio = item - 96;
        prioSum += prio;
    }
}

prioSum

#!markdown

Day 4 Part 1

#!csharp

#!share input4 --from value

var input = GetLines(input4);
var count = 0;
foreach(var cleaningTasks in input)
{
    
    var sections = cleaningTasks.Split(',').SelectMany(s => s.Split('-').Select(s=>int.Parse(s))).ToList();
    var first = new HashSet<int>(Enumerable.Range(sections[0], sections[1] - sections[0] + 1).ToList());
    var second = new HashSet<int>(Enumerable.Range(sections[2], sections[3] - sections[2] + 1).ToList());
    
    if(first.IsSubsetOf(second) || second.IsSubsetOf(first))
    {
        count++;
    }

}
count

#!markdown

Day 4 part 2

#!csharp

#!share input4 --from value

var input = GetLines(input4);
var count = 0;
foreach(var cleaningTasks in input)
{
    
    var sections = cleaningTasks.Split(',').SelectMany(s => s.Split('-').Select(s=>int.Parse(s))).ToList();
    var first = new HashSet<int>(Enumerable.Range(sections[0], sections[1] -sections[0] + 1).ToList());
    var second = new HashSet<int>(Enumerable.Range(sections[2], sections[3] -sections[2] + 1).ToList());
    
    if(first.Overlaps(second) || second.Overlaps(first))
    {
        count++;
    }

}
count

#!markdown

Day 5 Part 1

#!csharp

#!share input5 --from value

var input = GetLines(input5);
var stacks = new Dictionary<int, Stack<char>>();

foreach(var row in input)
{
    if(row.StartsWith(" 1"))
    {
        var tempStacks = new Dictionary<int, Stack<char>>();
        foreach(var s in stacks)
        {
            while(s.Value.Count > 0)
            {
                if(!tempStacks.ContainsKey(s.Key))
                {
                    tempStacks[s.Key] = new Stack<char>();
                }
                tempStacks[s.Key].Push(s.Value.Pop());
            }
        }
        stacks = tempStacks;
        continue;
    }
    if(string.IsNullOrEmpty(row))
    {
        continue;
    }

    if(!row.StartsWith("move"))
    {
        var crates = row.Split(' ');
        var i = 0;
        var stackIndex = 0;
        while(i < crates.Length)
        {
            if(string.IsNullOrEmpty(crates[i]))
            {
                i += 4;
            }
            else
            {
                if(!stacks.ContainsKey(stackIndex))
                {
                    stacks[stackIndex] = new Stack<char>();
                }
                stacks[stackIndex].Push(crates[i][1]);
                i++;
            }
            stackIndex++;
        }
    }
    else
    {
        var instructions = row.Split(' ');
        var count = int.Parse(instructions[1]);
        var source = int.Parse(instructions[3]) - 1;
        var destination = int.Parse(instructions[5]) - 1;

        for(var x = 0; x < count; x++)
        {
            var itemToMove = stacks[source].Pop();
            stacks[destination].Push(itemToMove);
        }
    }
}

display(new string(stacks.OrderBy(s=>s.Key).Select(s=>s.Value.Pop()).ToArray()));

#!markdown

Day 5 Part 2

#!csharp

#!share input5 --from value

var input = GetLines(input5);
var stacks = new Dictionary<int, Stack<char>>();

foreach(var row in input)
{
    if(row.StartsWith(" 1"))
    {
        var tempStacks = new Dictionary<int, Stack<char>>();
        foreach(var s in stacks)
        {
            while(s.Value.Count > 0)
            {
                if(!tempStacks.ContainsKey(s.Key))
                {
                    tempStacks[s.Key] = new Stack<char>();
                }
                tempStacks[s.Key].Push(s.Value.Pop());
            }
        }
        stacks = tempStacks;
        continue;
    }
    if(string.IsNullOrEmpty(row))
    {
        continue;
    }

    if(!row.StartsWith("move"))
    {
        var crates = row.Split(' ');
        var i = 0;
        var stackIndex = 0;
        while(i < crates.Length)
        {
            if(string.IsNullOrEmpty(crates[i]))
            {
                i += 4;
            }
            else
            {
                if(!stacks.ContainsKey(stackIndex))
                {
                    stacks[stackIndex] = new Stack<char>();
                }
                stacks[stackIndex].Push(crates[i][1]);
                i++;
            }
            stackIndex++;
        }
    }
    else
    {
        var instructions = row.Split(' ');
        var count = int.Parse(instructions[1]);
        var source = int.Parse(instructions[3]) - 1;
        var destination = int.Parse(instructions[5]) - 1;

        var itemsToMove = new Stack<char>();
        for(var x = 0; x < count; x++)
        {
            itemsToMove.Push(stacks[source].Pop());
        }
        while(itemsToMove.Count > 0)
        {
            var item = itemsToMove.Pop();
            stacks[destination].Push(item);
        }

    }
}

display(new string(stacks.OrderBy(s=>s.Key).Select(s=>s.Value.Pop()).ToArray()));

#!markdown

Day 6 Part 1

#!csharp

#!share input6 --from value

var input = input6;

var result = 0;
for(var i = 3; i < input.Length; i++)
{
    var substring = input[(i-3)..(i+1)];
    if(substring.Distinct().Count() == 4)
    {
        result = i + 1;
        break;
    }
}
result

#!markdown

Day 6 Part 2

#!csharp

#!share input6 --from value

var input = input6;

var result = 0;
for(var i = 13; i < input.Length; i++)
{
    var substring = input[(i-13)..(i+1)];
    if(substring.Distinct().Count() == 14)
    {
        result = i + 1;
        break;
    }
}
result

#!markdown

Day 7 Build directory tree

#!csharp

#!share input7 --from value

class Node
{
    public Node(string name)
    {
        Name = name;
        Id = Guid.NewGuid();
    }
    public Guid Id { get; }
    public Node? Parent { get; set; }
    public string Name { get; }
    public List<Node>? Children { get; set; }
    public long Size { get; set; }
}
    

    var input = GetLines(input7);
    var currentNode = new Node("/");
    var directoryTracker = new Dictionary<Guid, long>();
    foreach (var line in input.Skip(1))
    {
        var command = line.Split(' ');
        if (command[0] == "$")
        {
            switch (command[1])
            {
                case "cd":
                    if (command[2] == "..")
                    {
                        currentNode = currentNode.Parent;
                    }
                    else
                    {
                        currentNode = currentNode.Children.Single(n => n.Name == command[2]);
                    }
                    break;
                case "ls":
                    currentNode.Children = new List<Node>();
                    break;
            }
        }
        else
        {
            if (command[0] == "dir")
            {
                currentNode.Children.Add(new Node(command[1]) { Parent = currentNode });
            }
            else
            {
                var fileSize = long.Parse(command[0]);
                currentNode.Children.Add(new Node(command[1]) { Parent = currentNode, Size = fileSize });
                directoryTracker.TryGetValue(currentNode.Id, out var dirSize);
                directoryTracker[currentNode.Id] = dirSize + fileSize;
                var tempNode = currentNode;
                while (tempNode.Name != "/")
                {
                    tempNode = tempNode.Parent;
                    directoryTracker.TryGetValue(tempNode.Id, out var parentDirSize);
                    directoryTracker[tempNode.Id] = parentDirSize + fileSize;
                }
            }
        }
    }
    directoryTracker

#!markdown

Day 7 Part 1

#!csharp

var day7p1Result = directoryTracker.Where(kv => kv.Value < 100_000).Sum(kv => kv.Value);
day7p1Result

#!markdown

Day 7 Part 2

#!csharp

var diskCapacity = 70_000_000;
var unused = diskCapacity - directoryTracker.Max(kv => kv.Value);
var minToIncreaseAboveThreshold = directoryTracker.Where(kv=>kv.Value + unused > 30_000_000).Min(kv=>kv.Value);
minToIncreaseAboveThreshold

#!markdown

Day 8 Part 1

#!csharp

#!share input8 --from value 
var input = GetLines(input8);

var visibleFromEdge = new HashSet<(int x, int y)>();
var xMax = input[0].Length - 1;
var yMax = input.Length - 1;

// look from top
for(int x = 0; x < input[0].Length; x++)
{
    var highest =(char)('0'-1);
    var y = 0;
    var tree = input[y][x];
    while(y < yMax)
    {
        if(tree > highest)
        {
            visibleFromEdge.Add((x,y));
            highest = tree;
        }
        y++; 
        tree= input[y][x];
    }
}
// look from bottom
for(int x = 0; x < input[0].Length; x++)
{
    var highest = (char)('0'-1);
    var y = yMax;
    var tree = input[y][x];
    while(y > 0)
    {
        if(tree > highest)
        {
            visibleFromEdge.Add((x,y));
            highest = tree;
        }
        y--;
        tree= input[y][x];
    }
}
// look from left
for(int y = 0; y < input.Length; y++)
{
    var highest =(char)('0'-1);
    var x = 0;
    var tree = input[y][x];
    while(x < xMax)
    {
        if(tree > highest)
        {
            visibleFromEdge.Add((x,y));
            highest = tree;
        }        x++;
        tree= input[y][x];
    }
}
// look from right
for(int y = 0; y < input.Length; y++)
{
    var highest =(char)('0'-1);
    var x = xMax;
    var tree = input[y][x];
    while(x > 0)
    {
        if(tree > highest)
        {
            visibleFromEdge.Add((x,y));
            highest = tree;
        }
        x--;
        tree= input[y][x]; 
    }
}
visibleFromEdge.Count

#!markdown

Day 8 Part 2

#!csharp

var input = GetLines(input8);
var yMax= input.Length;
var xMax= input[0].Length;
var scenicScore = 0;
for(var y = 0; y < yMax; y++)
{
    for(var x = 0; x < xMax; x++)
    {
       var treeHouse = input[y][x];
        var viewDistanceUp = y == 0 ? 0 : 1;
        while (y - viewDistanceUp > 0 && input[y - viewDistanceUp][x] < treeHouse)
        {
            viewDistanceUp++;
        }
        var viewDistanceDown = y == yMax - 1 ? 0 : 1;
        while (y + viewDistanceDown < yMax-1 && input[y + viewDistanceDown][x] < treeHouse)
        {
            viewDistanceDown++;
        }
        var viewDistanceLeft = x == 0 ? 0 : 1;
        while (x - viewDistanceLeft > 0 && input[y][x - viewDistanceLeft] < treeHouse)
        {
            viewDistanceLeft++;
        }
        var viewDistanceRight = x == xMax - 1 ? 0 : 1;
        while (x + viewDistanceRight < xMax-1 && input[y][x + viewDistanceRight] < treeHouse)
        {
            viewDistanceRight++;
        }
        var newScore = viewDistanceDown * viewDistanceUp * viewDistanceLeft * viewDistanceRight;
        if (newScore > scenicScore)
        {
            scenicScore = newScore;
        }
    }
}
scenicScore

#!markdown

Day 9 Part 1

#!csharp

#!share input9 --from value

var input = GetLines(input9);
var tailUnique = new HashSet<(int, int)>();
(int x, int y) hPos = (0, 0);
(int x, int y) tPos = (0, 0);

(int x, int y) Move((int x, int y) particle, string dir)
{
    switch (dir)
    {
        case "R":
            return (particle.x + 1, particle.y);
        case "L":
            return (particle.x - 1, particle.y);
        case "U":
            return (particle.x, particle.y + 1);
        case "D":
            return (particle.x, particle.y - 1);
        default:
            throw new ArgumentOutOfRangeException();
    }
}

foreach (var i in input)
{
    var movement = i.Split(' ');
    var length = int.Parse(movement[1]);
    var dir = movement[0];

    for (var s = 0; s < length; s++)
    {
        hPos = Move(hPos, dir);

        var h = new System.Numerics.Vector2(hPos.x, hPos.y);
        var t = new System.Numerics.Vector2(tPos.x, tPos.y);
        var distance = System.Numerics.Vector2.Distance(h, t);
        if (distance == 2f)
        {
            tPos = Move(tPos, dir);
        }
        if (System.Math.Abs(distance - System.Math.Sqrt(5)) < 0.001)
        {
            tPos = Move(tPos, dir);
            var diff = h - new System.Numerics.Vector2(tPos.x, tPos.y);
            if (dir == "R" || dir == "L")
            {
                tPos = (tPos.x, tPos.y + (int)diff.Y);
            }
            if (dir == "U" || dir == "D")
            {
                tPos = (tPos.x + (int)diff.X, tPos.y);
            }
        }
        tailUnique.Add(tPos);
    }
}

var result = tailUnique.Count;
result

#!markdown

Day 9 Part 2

#!csharp

#!share input9 --from value

var input = GetLines(input9);
var tailUnique = new HashSet<(int, int)>();
var knots = Enumerable.Repeat<(int x, int y)>((0, 0), 10).ToArray();

(int x, int y) Move((int x, int y) particle, string dir)
{
    switch (dir)
    {
        case "R":
            return (particle.x + 1, particle.y);
        case "L":
            return (particle.x - 1, particle.y);
        case "U":
            return (particle.x, particle.y + 1);
        case "D":
            return (particle.x, particle.y - 1);
        default:
            throw new ArgumentOutOfRangeException();
    }
}

foreach (var i in input)
{
    var movement = i.Split(' ');
    var length = int.Parse(movement[1]);
    var dir = movement[0];

    for (var s = 0; s < length; s++)
    {
        knots[0] = Move(knots[0], dir);

        for (int k = 1; k < knots.Length; k++)
        {
            var h = new System.Numerics.Vector2(knots[k - 1].x, knots[k - 1].y);
            var t = new System.Numerics.Vector2(knots[k].x, knots[k].y);
            var distance = System.Numerics.Vector2.Distance(h, t);
            if (distance < 2)
            {
                continue;
            }

            var diff = h - t;

            knots[k] = diff switch
            {
                { X: 1 or 2, Y: 1 or 2 } => (knots[k].x + 1, knots[k].y + 1),
                { X: 1 or 2, Y: -1 or -2 } => (knots[k].x + 1, knots[k].y - 1),
                { X: -1 or -2, Y: 1 or 2 } => (knots[k].x - 1, knots[k].y + 1),
                { X: -1 or -2, Y: -1 or -2 } => (knots[k].x - 1, knots[k].y - 1),

                { X: 0, Y: 2 } => (knots[k].x, knots[k].y + 1),
                { X: 0, Y: -2 } => (knots[k].x, knots[k].y - 1),
                { X: 2, Y: 0 } => (knots[k].x + 1, knots[k].y),
                { X: -2, Y: 0 } => (knots[k].x - 1, knots[k].y),
                _ => throw new Exception()
            };
        }

        tailUnique.Add(knots.Last());
    }
}

var result = tailUnique.Count;
result
