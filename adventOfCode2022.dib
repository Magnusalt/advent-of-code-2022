#!markdown

Read input from files

#!csharp

#!value --from-file input1.txt --name input1
#!value --from-file input2.txt --name input2
#!value --from-file input3.txt --name input3
#!value --from-file input4.txt --name input4
#!value --from-file input5.txt --name input5

#!markdown

Helpers

#!csharp

using System.Linq;

int[] ParseInput(string[] raw){
    return raw.Select(v=> int.Parse(v)).ToArray();
}

int[] ParseInput(string raw){
    return ParseInput(raw.Split('\n')).ToArray();
}

string[] GetLines(string input){
  return input.Split("\r\n");  
}

#!markdown

Day 1 part 1

#!csharp

#!share input1 --from value

var day1 = input1.Split("\r\n");
var most = 0;
var current = 0;
foreach(var cal in day1)
{
    if(string.IsNullOrEmpty(cal))
    {
        most = current > most ? current : most;
        current = 0;
    }
    else
    {
        current += int.Parse(cal);
    }
}
most

#!markdown

Day 1 part 2

#!csharp

#!share input1 --from value

var day1 = input1.Split("\r\n");
var most = new int[]{0,0,0};
var current = 0;
foreach(var cal in day1)
{
    if(string.IsNullOrEmpty(cal))
    {
        for(var i = 0; i < 3; i++)
        {
            if(current > most[i])
            {
                most[i] = current;
                break;
            }
        }
        current = 0;
    }
    else
    {
        current += int.Parse(cal);
    }
}
most.Sum()

#!markdown

Day 2 part 1

#!csharp

#!share input2 --from value

var input = GetLines(input2);

var res = input.Aggregate(0, (sum, next) =>{
    return sum + next switch {
        "A X" => 1+3,
        "A Y" => 2+6,
        "A Z" => 3+0,
        "B X" => 1+0,
        "B Y" => 2+3,
        "B Z" => 3+6,
        "C X" => 1+6,
        "C Y" => 2+0,
        "C Z" => 3+3,
        _ => throw new ArgumentOutOfRangeException($"{next} is invalid")
    };
});

res

#!markdown

Day 2 part 2

#!csharp

#!share input2 --from value

var input = GetLines(input2);

var res = input.Aggregate(0, (sum, next) =>{
    return sum + next switch {
        "A X" => 3+0,
        "A Y" => 1+3,
        "A Z" => 2+6,
        "B X" => 1+0,
        "B Y" => 2+3,
        "B Z" => 3+6,
        "C X" => 2+0,
        "C Y" => 3+3,
        "C Z" => 1+6,
    };
});

res

#!javascript

#!share input2 --from value

var input = input2.split("\r\n");
var rules = {        
    "A X" : 3+0,
    "A Y" : 1+3,
    "A Z" : 2+6,
    "B X" : 1+0,
    "B Y" : 2+3,
    "B Z" : 3+6,
    "C X" : 2+0,
    "C Y" : 3+3,
    "C Z" : 1+6,
};
var result = input.reduce((sum, next) =>sum + rules[next], 0);
console.log(result)

#!markdown

Day 3 part1

#!csharp

#!share input3 --from value

var input = GetLines(input3);
var prioSum = 0;
foreach(var rucksack in input)
{
    var size = rucksack.Length;
    var compartment1 = rucksack.Substring(0, size/2);
    var compartment2 = rucksack.Substring(size/2);

    foreach(var item in compartment2)
    {
        if(compartment1.Contains(item))
        {
            if(item < 91)
            {
                var prio = item - 65 + 27;
                prioSum += prio;
                break;
            }
            if(item > 96)
            {
                var prio = item - 96;
                prioSum += prio;
                break;
            }
        }
    }
}

prioSum

#!markdown

Day 3 Part 2

#!csharp

#!share input3 --from value

var input = GetLines(input3);
var prioSum = 0;
foreach(var group in input.Chunk(3))
{
    var intersection = group.First().ToList();
    foreach(var rucksack in group.Skip(1))
    {
        intersection = intersection.Intersect(rucksack).ToList();
    }
    var item = intersection.Single();
    if(item < 91)
    {
        var prio = item - 65 + 27;
        prioSum += prio;
    }
    if(item > 96)
    {
        var prio = item - 96;
        prioSum += prio;
    }
}

prioSum

#!markdown

Day 4 Part 1

#!csharp

#!share input4 --from value

var input = GetLines(input4);
var count = 0;
foreach(var cleaningTasks in input)
{
    
    var sections = cleaningTasks.Split(',').SelectMany(s => s.Split('-').Select(s=>int.Parse(s))).ToList();
    var first = new HashSet<int>(Enumerable.Range(sections[0], sections[1] - sections[0] + 1).ToList());
    var second = new HashSet<int>(Enumerable.Range(sections[2], sections[3] - sections[2] + 1).ToList());
    
    if(first.IsSubsetOf(second) || second.IsSubsetOf(first))
    {
        count++;
    }

}
count

#!markdown

Day 4 part 2

#!csharp

#!share input4 --from value

var input = GetLines(input4);
var count = 0;
foreach(var cleaningTasks in input)
{
    
    var sections = cleaningTasks.Split(',').SelectMany(s => s.Split('-').Select(s=>int.Parse(s))).ToList();
    var first = new HashSet<int>(Enumerable.Range(sections[0], sections[1] -sections[0] + 1).ToList());
    var second = new HashSet<int>(Enumerable.Range(sections[2], sections[3] -sections[2] + 1).ToList());
    
    if(first.Overlaps(second) || second.Overlaps(first))
    {
        count++;
    }

}
count

#!markdown

Day 5 Part 1

#!csharp

#!share input5 --from value

var input = GetLines(input5);
var stacks = new Dictionary<int, Stack<char>>();

foreach(var row in input)
{
    if(row.StartsWith(" 1"))
    {
        var tempStacks = new Dictionary<int, Stack<char>>();
        foreach(var s in stacks)
        {
            while(s.Value.Count > 0)
            {
                if(!tempStacks.ContainsKey(s.Key))
                {
                    tempStacks[s.Key] = new Stack<char>();
                }
                tempStacks[s.Key].Push(s.Value.Pop());
            }
        }
        stacks = tempStacks;
        continue;
    }
    if(string.IsNullOrEmpty(row))
    {
        continue;
    }

    if(!row.StartsWith("move"))
    {
        var crates = row.Split(' ');
        var i = 0;
        var stackIndex = 0;
        while(i < crates.Length)
        {
            if(string.IsNullOrEmpty(crates[i]))
            {
                i += 4;
            }
            else
            {
                if(!stacks.ContainsKey(stackIndex))
                {
                    stacks[stackIndex] = new Stack<char>();
                }
                stacks[stackIndex].Push(crates[i][1]);
                i++;
            }
            stackIndex++;
        }
    }
    else
    {
        var instructions = row.Split(' ');
        var count = int.Parse(instructions[1]);
        var source = int.Parse(instructions[3]) - 1;
        var destination = int.Parse(instructions[5]) - 1;

        for(var x = 0; x < count; x++)
        {
            var itemToMove = stacks[source].Pop();
            stacks[destination].Push(itemToMove);
        }
    }
}

display(new string(stacks.OrderBy(s=>s.Key).Select(s=>s.Value.Pop()).ToArray()));

#!markdown

Day 5 Part 2

#!csharp

#!share input5 --from value

var input = GetLines(input5);
var stacks = new Dictionary<int, Stack<char>>();

foreach(var row in input)
{
    if(row.StartsWith(" 1"))
    {
        var tempStacks = new Dictionary<int, Stack<char>>();
        foreach(var s in stacks)
        {
            while(s.Value.Count > 0)
            {
                if(!tempStacks.ContainsKey(s.Key))
                {
                    tempStacks[s.Key] = new Stack<char>();
                }
                tempStacks[s.Key].Push(s.Value.Pop());
            }
        }
        stacks = tempStacks;
        continue;
    }
    if(string.IsNullOrEmpty(row))
    {
        continue;
    }

    if(!row.StartsWith("move"))
    {
        var crates = row.Split(' ');
        var i = 0;
        var stackIndex = 0;
        while(i < crates.Length)
        {
            if(string.IsNullOrEmpty(crates[i]))
            {
                i += 4;
            }
            else
            {
                if(!stacks.ContainsKey(stackIndex))
                {
                    stacks[stackIndex] = new Stack<char>();
                }
                stacks[stackIndex].Push(crates[i][1]);
                i++;
            }
            stackIndex++;
        }
    }
    else
    {
        var instructions = row.Split(' ');
        var count = int.Parse(instructions[1]);
        var source = int.Parse(instructions[3]) - 1;
        var destination = int.Parse(instructions[5]) - 1;

        var itemsToMove = new Stack<char>();
        for(var x = 0; x < count; x++)
        {
            itemsToMove.Push(stacks[source].Pop());
        }
        while(itemsToMove.Count > 0)
        {
            var item = itemsToMove.Pop();
            stacks[destination].Push(item);
        }

    }
}

display(new string(stacks.OrderBy(s=>s.Key).Select(s=>s.Value.Pop()).ToArray()));
